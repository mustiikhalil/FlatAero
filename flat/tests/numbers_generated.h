// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NUMBERS_H_
#define FLATBUFFERS_GENERATED_NUMBERS_H_

#include "flatbuffers/flatbuffers.h"

struct Position;

struct PIValue;
struct PIValueBuilder;

struct Numbers;
struct NumbersBuilder;

enum Values {
  Values_l1 = 0,
  Values_l2 = 1,
  Values_l3 = 2,
  Values_MIN = Values_l1,
  Values_MAX = Values_l3
};

inline const Values (&EnumValuesValues())[3] {
  static const Values values[] = {
    Values_l1,
    Values_l2,
    Values_l3
  };
  return values;
}

inline const char * const *EnumNamesValues() {
  static const char * const names[4] = {
    "l1",
    "l2",
    "l3",
    nullptr
  };
  return names;
}

inline const char *EnumNameValues(Values e) {
  if (flatbuffers::IsOutRange(e, Values_l1, Values_l3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValues()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Position FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Position() {
    memset(static_cast<void *>(this), 0, sizeof(Position));
  }
  Position(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 12);

struct PIValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PIValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PIValueBuilder {
  typedef PIValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PIValue::VT_NAME, name);
  }
  explicit PIValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PIValueBuilder &operator=(const PIValueBuilder &);
  flatbuffers::Offset<PIValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PIValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<PIValue> CreatePIValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  PIValueBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PIValue> CreatePIValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreatePIValue(
      _fbb,
      name__);
}

struct Numbers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NumbersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES1 = 4,
    VT_VALUES2 = 6,
    VT_N1 = 8,
    VT_N2 = 10,
    VT_N3 = 12,
    VT_N4 = 14,
    VT_N5 = 16,
    VT_N6 = 18,
    VT_N7 = 20,
    VT_N8 = 22,
    VT_N9 = 24,
    VT_N10 = 26,
    VT_N11 = 28,
    VT_P = 30,
    VT_PI = 32
  };
  Values values1() const {
    return static_cast<Values>(GetField<int32_t>(VT_VALUES1, 0));
  }
  Values values2() const {
    return static_cast<Values>(GetField<int32_t>(VT_VALUES2, 0));
  }
  int8_t n1() const {
    return GetField<int8_t>(VT_N1, 0);
  }
  uint8_t n2() const {
    return GetField<uint8_t>(VT_N2, 0);
  }
  bool n3() const {
    return GetField<uint8_t>(VT_N3, 0) != 0;
  }
  int16_t n4() const {
    return GetField<int16_t>(VT_N4, 0);
  }
  uint16_t n5() const {
    return GetField<uint16_t>(VT_N5, 0);
  }
  int32_t n6() const {
    return GetField<int32_t>(VT_N6, 0);
  }
  uint32_t n7() const {
    return GetField<uint32_t>(VT_N7, 0);
  }
  int64_t n8() const {
    return GetField<int64_t>(VT_N8, 0);
  }
  uint64_t n9() const {
    return GetField<uint64_t>(VT_N9, 0);
  }
  float n10() const {
    return GetField<float>(VT_N10, 0.0f);
  }
  double n11() const {
    return GetField<double>(VT_N11, 0.0);
  }
  const Position *p() const {
    return GetStruct<const Position *>(VT_P);
  }
  const PIValue *pi() const {
    return GetPointer<const PIValue *>(VT_PI);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES1) &&
           VerifyField<int32_t>(verifier, VT_VALUES2) &&
           VerifyField<int8_t>(verifier, VT_N1) &&
           VerifyField<uint8_t>(verifier, VT_N2) &&
           VerifyField<uint8_t>(verifier, VT_N3) &&
           VerifyField<int16_t>(verifier, VT_N4) &&
           VerifyField<uint16_t>(verifier, VT_N5) &&
           VerifyField<int32_t>(verifier, VT_N6) &&
           VerifyField<uint32_t>(verifier, VT_N7) &&
           VerifyField<int64_t>(verifier, VT_N8) &&
           VerifyField<uint64_t>(verifier, VT_N9) &&
           VerifyField<float>(verifier, VT_N10) &&
           VerifyField<double>(verifier, VT_N11) &&
           VerifyField<Position>(verifier, VT_P) &&
           VerifyOffset(verifier, VT_PI) &&
           verifier.VerifyTable(pi()) &&
           verifier.EndTable();
  }
};

struct NumbersBuilder {
  typedef Numbers Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values1(Values values1) {
    fbb_.AddElement<int32_t>(Numbers::VT_VALUES1, static_cast<int32_t>(values1), 0);
  }
  void add_values2(Values values2) {
    fbb_.AddElement<int32_t>(Numbers::VT_VALUES2, static_cast<int32_t>(values2), 0);
  }
  void add_n1(int8_t n1) {
    fbb_.AddElement<int8_t>(Numbers::VT_N1, n1, 0);
  }
  void add_n2(uint8_t n2) {
    fbb_.AddElement<uint8_t>(Numbers::VT_N2, n2, 0);
  }
  void add_n3(bool n3) {
    fbb_.AddElement<uint8_t>(Numbers::VT_N3, static_cast<uint8_t>(n3), 0);
  }
  void add_n4(int16_t n4) {
    fbb_.AddElement<int16_t>(Numbers::VT_N4, n4, 0);
  }
  void add_n5(uint16_t n5) {
    fbb_.AddElement<uint16_t>(Numbers::VT_N5, n5, 0);
  }
  void add_n6(int32_t n6) {
    fbb_.AddElement<int32_t>(Numbers::VT_N6, n6, 0);
  }
  void add_n7(uint32_t n7) {
    fbb_.AddElement<uint32_t>(Numbers::VT_N7, n7, 0);
  }
  void add_n8(int64_t n8) {
    fbb_.AddElement<int64_t>(Numbers::VT_N8, n8, 0);
  }
  void add_n9(uint64_t n9) {
    fbb_.AddElement<uint64_t>(Numbers::VT_N9, n9, 0);
  }
  void add_n10(float n10) {
    fbb_.AddElement<float>(Numbers::VT_N10, n10, 0.0f);
  }
  void add_n11(double n11) {
    fbb_.AddElement<double>(Numbers::VT_N11, n11, 0.0);
  }
  void add_p(const Position *p) {
    fbb_.AddStruct(Numbers::VT_P, p);
  }
  void add_pi(flatbuffers::Offset<PIValue> pi) {
    fbb_.AddOffset(Numbers::VT_PI, pi);
  }
  explicit NumbersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NumbersBuilder &operator=(const NumbersBuilder &);
  flatbuffers::Offset<Numbers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Numbers>(end);
    return o;
  }
};

inline flatbuffers::Offset<Numbers> CreateNumbers(
    flatbuffers::FlatBufferBuilder &_fbb,
    Values values1 = Values_l1,
    Values values2 = Values_l1,
    int8_t n1 = 0,
    uint8_t n2 = 0,
    bool n3 = false,
    int16_t n4 = 0,
    uint16_t n5 = 0,
    int32_t n6 = 0,
    uint32_t n7 = 0,
    int64_t n8 = 0,
    uint64_t n9 = 0,
    float n10 = 0.0f,
    double n11 = 0.0,
    const Position *p = 0,
    flatbuffers::Offset<PIValue> pi = 0) {
  NumbersBuilder builder_(_fbb);
  builder_.add_n11(n11);
  builder_.add_n9(n9);
  builder_.add_n8(n8);
  builder_.add_pi(pi);
  builder_.add_p(p);
  builder_.add_n10(n10);
  builder_.add_n7(n7);
  builder_.add_n6(n6);
  builder_.add_values2(values2);
  builder_.add_values1(values1);
  builder_.add_n5(n5);
  builder_.add_n4(n4);
  builder_.add_n3(n3);
  builder_.add_n2(n2);
  builder_.add_n1(n1);
  return builder_.Finish();
}

inline const Numbers *GetNumbers(const void *buf) {
  return flatbuffers::GetRoot<Numbers>(buf);
}

inline const Numbers *GetSizePrefixedNumbers(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Numbers>(buf);
}

inline bool VerifyNumbersBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Numbers>(nullptr);
}

inline bool VerifySizePrefixedNumbersBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Numbers>(nullptr);
}

inline void FinishNumbersBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Numbers> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNumbersBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Numbers> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_NUMBERS_H_
